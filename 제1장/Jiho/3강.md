## chap 01 DBMS 아키텍처

<br>

### 3강 DBMS와 실행 계획

- 사용자 또는 개발자가 데이터베이스에서 의식적으로 사용하는 것은 SQL 레벨까지이다. 이 후의 모든 것은 SQL 구문을 읽어들인 DBMS가 알아서 처리하고 결과를 제공해준다. 따라서 사용자는 데이터가 있는 곳을 알 필요도 없고, 데이터에 접근하는 방법도 따로 생각하지 않는다. 이러한 모든 것은 DBMS에 맡긴다.

- 이러한 과정은 보통 '프로그래밍'이라고 말하는 것과는 거리가 멀다. 데이터를 검색 또는 갱신하는 처리를 일반적인 프로그래밍 언어로한다면, 어디에 있는 데이터를 어떻게 찾고 처리할지 등의 절차적인 세부사항을 모두 작성해줘야 한다. 그런데 SQL은 그러한 절차적인 것을 전혀 기술하지 않고 사용한다.

<hr>

1. 권한 이양의 죄악

- 언어의 설계 사상 차이. C, 자바, 루비와 같은 절차가 기초가 되는 언어는 사용자가 데이터에 접근하기 위한 절차(How)를 책임지고 기술하는 것이 전제이다. 반면 비절차적인 RDB는 그러한 모든 일을 사용자가 아니라 시스템에 맡겼다. 따라서 사용자가 하는 일은 대상(What)을 기술하는 것으로 축소되었다.
- RDB가 권한이양을 한 이유는 '비즈니스 전체의 생산성 향상'을 위함이다.

2. 데이터에 접근하는 방법은 어떻게 결정할까?

- RDB에서 데이터 접근 절차를 결정하는 모듈은 쿼리 평가 엔진이라고 부른다. 쿼리 평가 엔진은 사용자로부터 입력받은 SQL 구문(쿼리)을 처음 읽어들이는 모듈이기도 하다. 쿼리 평가 모듈은 추가로 파서 또는 옵티마이저와 같은 여러 개의 서브 모듈로 구성된다.

<hr>

- 파서(parser)

* 파서의 역할은 이름 그대로 파스(구문 분석)하는 것이다. 사용자로부터 입력받은 SQL구문이 항상 구문적으로 올바르다는 보증이 없으므로 검사를 해주는 것이다. 사용자가 쉼표 쓰는 것을 잊거나, FROM 구에 존재하지 않는 테이블 이름을 쓰거나 했을 때는 서류 심사에서 미리 떨어뜨리는 것이다. 또한 파서는 SQL 구문을 정형적인 형식으로 변환해준다. 그렇게 해야 DBMS 내부에서 일어나는 후속 처리가 효율화된다. 사실 구문 분석이라는 것은 SQL에 한정되는 것이 아니라 일반 프로그래밍 언어의 컴파일 시점에서도 실행되는 것이다.

- 옵티마이저(optimizer)

* 서류 심사를 통과한 쿼리는 옵티마이저로 전송된다. 옵티마이저의 한국어 번역은 '최적화'이다. 이때 최적화의 대상은 데이터 접근법(실행 계획)이다. 옵티마이저가 바로 DBMS 두뇌의 핵심이다.

* 옵티마이저는 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서, 선택 가능한 많은 실행 계획을 작성하고, 이들의 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택한다.
* 접근법의 수가 많이 나온다면 그 비용을 계산하고 비교해야 하는데 사람이 하기에는 굉장히 귀찮은 일이다. RDB가 데이터 접근의 절차 지향 결정을 자동화하는 이유는 이런 귀찮을 일을 기계적으로 처리해주기 위함이다.

- 카탈로그 매니저(catalog manager)

* 옵티마이저가 실행 계획을 세울 때 옵티마이저에 중요한 정보를 제공하는 것이 카탈로그 매니저이다.

* 카탈로그란? DBMS의 내부 정보를 모아놓은 테이블들로, 테이블 또는 인덱스의 통계 정보가 저장되어 있다. 따라서 이러한 카탈로그 정보를 간단하게 '통계 정보'라고 부르기도 한다.

- 플랜 평가(plan evaluation)

* 옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 그것을 받아 최적화 실행 결과를 선택하는 것이 플랜 평가이다. 실행 계획이라는 것은 곧바로 DBMS가 실행할 수 있는 형태의 코드가 아니다. 오히려 인간이 읽기 쉽게 만들어진 문자 그대로의 '계획서'이다. 따라서 성능이 좋지 않는 SQL 구문이 있을 때 실행 계획을 읽고, 수정 방안 등을 고려할 수 있다.

이렇게 해서 하나의 실행 계획을 선택하며, 이후에 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행한다.

<hr>

3. 옵티마이저와 통계 정보

- 옵티마이저 내부에서 일어나는 처리는 엔진 자체를 구현하는 엔지니어 이외에는 관계가 없으므로 다루지 않는다. 오히려 데이터베이스 사용자로서는 옵티마이저를 잘 사용하는 것이 더 중요하다. 이렇게 말하는 이유는 옵티마이저가 명령하는 대로 잘 처리해주는 만능은 아니기 때문이다. 특히 카탈로그 매니저가 관리하는 통계 정보에 대해서는 데이터베이스 엔지니어가 항상 신경 써줘야 한다.

- 카탈로그에 포함되어 있는 통계 정보는 다음과 같은 것들이다.
  - 각 테이블의 레코드 수
  - 각 테이블의 필드 수와 필드의 크기
  - 필드의 카디널리티 (값의 개수)
  - 필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
  - 필드 내부에 있는 NULL 수
  - 인덱스 정보

이러한 정보를 활용함으로써 옵티마이저는 실행 계획을 만든다. 문제가 생기는 경우는 이러한 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 때이다. 테이블에 데이터 삽입/갱신/제거가 수행될 때 카탈로그 정보가 갱신되지 않는다면, 옵티마이저는 오래된 정보를 바탕으로 실행 계획을 세우게 된다. 옵티마이저는 과거 정보밖에 가지고 있지 않으므로 어쩔 수 없이 잘못된 계획을 세울 수밖에 없다.

4. 최적의 실행 계획이 작성되게 하려면

- 올바른 통계 정보가 모이는 것은 SQL 성능에 있어서 굉장히 중요한 문제이다. 따라서 테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 한다는 것은 데이터베이스 엔지니어 사이의 상식이다. 수동으로 갱신하는 것뿐만 아니라, 데이터를 크게 갱신하는 배치 처리가 있을 때는 Job Net을 조합하는 경우도 많고, Oracle처럼 기본 설정에서 정기적으로 통계 정보 갱신 작업(Job)이 수행되는 경우도 있으며, Microsoft SQL Server처럼 갱신 처리가 수행되는 시점에 자동으로 통계 정보를 갱신하는 DBMS도 있다.

- 통계 정보 갱신은 대상 테이블 또는 인덱스의 크기와 수에 따라서 몇십 분에서 몇시간이 소요되기도 하는, 실행 비용이 굉장히 높은 작업이다. 하지만 DBMS가 최적의 플랜을 선택하려면 필요한 조건이므로 갱신 시점을 확실하게 검토해야 한다.

- 각 DBMS의 통계 정보 갱신 명령어는 책을 참고하세요.
