## chap 01 DBMS 아키텍처

<br>

### 2강 DBMS와 버퍼

버퍼 매니저는 어떤 기능을 수행하는지 알아보자.

버퍼는 성능에 굉장한 중요한 역할을 미친다.

메모리는 한정된 희소자원. 반면 데이터베이스가 메모리에 저장하고자 하는 데이터는 굉장히 많다.

따라서 데이터를 버퍼에 어떠한 식으로 확보할 것인가 하는 부분에서 트레이드오프가 발생한다.

<hr>

### 1. 공짜 밥은 존재할까?

- 기억비용 : 데이터를 저장하는데 소모되는 비용

많은 데이터를 영속적으로 저장하려 하면 속도를 잃고, 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들다는 트레이드오프 발생

속도와 영속성을 동시에 확보하기란 어렵다.

→ 시스템의 세계에는 공짜 밥이라는 것이 없다.

<hr>

### 2. DMBS와 기억장치의 관계

DBMS는 데이터 저장을 목적으로 하는 미들웨어. 따라서 기억장치와 떨어뜨릴 수 없는 관계

#### DBMS가 사용하는 대표적인 기억장치 2가지

1. 하드디스크(HDD)

- DBMS가 데이터를 저장하는 매체(저장소)는 현재 대부분 HDD이다. 다른 많은 선택사항이 있지만 용량, 비용, 성능의 관점에서 대부분 하드디스크를 선택함.
- 하드디스크는 기억장치 계층에서 한가운데 있는 2차 기억장치로 분류
  2차 기억장치는 그렇게 좋은 장점도 없지만, 그렇게 나쁜 단점도 없는 매체
- 일반적인 DBMS는 항상 디스크 이외의 장소에도 데이터를 올려 놓는다. 바로 1차 계층의 기억장치 메모리에 올려 놓는다.

2. 메모리

- 메모리는 디스크에 비해 기억 비용이 굉장히 비싸다. 따라서 하드웨어 1대에 탑재할 수 잇는 양이 크지 않다.
- 일반적인 데이터베이스 서버의 경우 탑재되는 메모리의 양은 한두 자리 정도. 아무리 많다고 해도 100GB를 넘는 경우는 거의 없다.
- 테라바이트 단위의 용량을 가지는 하드디스크와 비교하면 엄청나게 작은 크기
- 따라서 규모 있는 상용 시스템의 데이터베이스 내부 데이터를 모두 메모리에 올리는 것은 불가능

3. 버퍼를 활용한 속도 향상

- DBMS가 일부라도 데이터를 메모리에 올리는 것은 성능 향상 때문!
- 한마디로 **SQL구문의 실행 속도를 빠르게 만들기 위함**
- 메모리는 가장 빠른 1차 기억장치
- 따라서 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터를 검색할 수 있다.

- 디스크 접근을 줄일 수 있다면 굉장히 큰 폭의 성능 향상이 가능
- 일반적인 SQL 구문의 실행 시간 대부분을 저장소 I/O(입출력)에 사용하기 때문

- 이렇게 성능향상을 목적으로 데이터를 저장하는 메모리를 **버퍼(buffer)** 또는 **캐시(cache)**라고 부른다. 버퍼는 '완충제'라는 의미. 사용자와 저장소 사이에서 SQL 구문의 디스크 접근을 줄여주는 역할을 하므로 붙은 이름
- 캐시 역시 사용자와 저장소 사이에서 데이터 전송 지연을 완화시켜주는 것. 모두 물리적인 매체로 메모리가 사용되는 경우가 많음. 따라서 하드디스크 위에 있는 데이터에 접근하는 것보다 훨씬 빠르다.

<br>

> 고속 접근이 가능한 버퍼에 '데이터를 어떻게, 어느 정도의 기간 동안 올릴지'를 관리하는 것이 DBMS의 버퍼 매니저. 이러한 것을 생각하면 버퍼 매니저가 데이터베이스의 성능에 굉장히 중요한 영향을 끼친다는 것을 쉽게 이해할 수 있다.

<hr>

### 3. 메모리 위에 있는 두 개의 버퍼

DBMS가 데이터를 유지하기 위해 사용하는 메모리는 다음과 같이 두 종류

- 데이터 캐시
- 로그 버퍼

버퍼는 사용자가 용도에 따라 크기를 변경하는 것이 가능하다.

#### ▷ 데이터 캐시

- 데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역
- 만약 실행한 SELECT 구문에서 선택하고 싶은 데이터가 운 좋게 모두 이러한 데이터 캐시에 있다면 디스크와 같은 저속 저장소에 접근하지 않고 처리가 수행된다. 따라서 굉장히 빠르게 응답한다.
- 반대로 운 나쁘게 버퍼에서 데이터를 찾을 수 없다면, 저속 저장소까지 데이터를 가지러 가야 한다. 따라서 SQL 구문의 응답 속도가 느려진다. 데이터베이스 세계에는 '디스크를 건드리는 자는 불행해진다'라는 오래된 격언이 있다.

#### ▷ 로그 버퍼

- 로그 버퍼는 갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 관련 있다. DMBS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면, 곧바로 저장소에 있는 데이터를 변경하지 않는다. 일단 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다.
- 데이터베이스의 갱신 처리는 SQL 구문의 실행 시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리이다.
- SQL구문을 실행할 때 단순히 저장소 상의 파일을 바로 변경해버리는 편이 간단한 방법이다. 그럼에도 DBMS가 이러한 시점 차이를 두는 이유는 역시 성능을 높이기 위해서이다. 저장소는 검색뿐만 아니라 갱신을 할 때도 상당히 시간이 소모된다. 따라서 저장소 변경이 끝날 때까지 기다리면 사용자는 장기간 대기하게 된다. 따라서 한 번 메모리에 갱신 정보를 받은 시점에서 사용자에겐느 해당 SQL 구문이 '끝났다'라고 통지하고, 내부적으로 관련된 처리를 계속 수행하는 것이다.

> DBMS는 '저장소의 느림을 어떻게 보완할 것인가'라는 것을 계속해서 고민해온 미들웨어이다. DMBS는 오래전부터 저속 저장소로 인한 성능 문제를 어떻게 해결할 수 있을지 계속 고민했다. 그리고 이러한 고민에 대한 답으로 복잡한 버퍼 매커니즘을 탑재하게 되었다.

<hr>

### 4. 메모리의 성질이 초래하는 트레이드오프

'메모리가 가진 단점은 가격이 비싸서 보유할 수 있는 데이터 양이 적은 것이다' 라고 이야기하였다.

- 휘발성

* 메모리에는 데이터의 영속성이 없다. 하드웨어의 전원을 꺼버리면 메모리 위에 올라가 있는 모든 데이터가 사라져 버리는데, 이러한 성질을 **휘발성**이라고 부른다.
* DBMS를 껐다 켜면 버퍼 위의 모든 데이터가 사라진다. 따라서 DBMS에 어떤 장애가 발생해서 프로세스다운이 일어나면(즉, 서버가 죽으면), 메모리 위에 있는 모든 데이터가 날아간다. 결국 미래에 메모리 가격이 엄청나게 싸진다고 해도, 영속성이 없는 이상 기능적으로 디스크를 완전히 대체하는 것은 불가능하다.

- 휘발성의 문제점

* 휘발성의 가장 큰 문제점은 장애가 발생했을 때 메모리에 있던 데이터가 모두 사라져버려 데이터 부정합을 발생시키는 것이다. 데이터 캐시라면 장애로 인해 메모리 위의 데이터가 사라져버려도, 원본 데이터는 디스크 위에 남아있으므로 아무 문제 없다. 그냥 디스크에서 데이터를 한 번 더 읽어들이면 된다. 따라서 시간이 더 걸리기는 하겠지만, 결과에는 아무 문제 없다.
* 로그 파일에 전달된 갱신 정보가 DBMS에 다운될 때 사라지는 현상은 DBMS가 갱신을 비동기로 하는 이상, 언제든 발생할 수 있는 문제이다. 따라서 이를 회피하고자 DBMS는 커밋 시점에 반드시 갱신 정보를 로그 파일(이는 영속적인 저장소 위에 존재합니다)에 씀으로써, 장애가 발생해도 정합성을 유지할 수 있게 한다. **커밋(Commit)**이란 갱신 처리를 '확정'하는 것이며, DBMS는 커밋된 데이터를 영속화한다.
* 반대로 말하면 커밋 때는 반드시 디스크에 동기 접근이 일어난다. 결국 여기서 지연이 발생할 가능성이 있다. 여기에서도 또다시 트레이드오프가 모습을 드러낸다. 디스크에 동기 처리를 한다면 데이터 정합성은 높아지지만 성능이 낮아진다. 반대로 성능을 높이려면 데이터 정합성이 낮아진다.

| 이름        | 데이터정합성 | 성능 |
| ----------- | ------------ | ---- |
| 동기 처리   | O            | X    |
| 비동기 처리 | X            | O    |

<hr>

### 5. 시스템 특성에 따른 트레이드 오프

- 데이터 캐시와 로그 버퍼의 크기

* 데이터 캐시에 비해 로그 버퍼의 초깃값이 굉장히 작다는 것을 알 수 있다. 2개의 버퍼에 대해 이렇게 극단적으로 비대칭적인 크기를 할당한 데는 명확한 이유가 있다. 이는 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문이다.
* 검색 처리를 할 때는 검색 대상 레코드가 수백만에서 수천만 건에 달하는 경우도 많다. 하지만 갱신처리를 할 때는 갱신 대상이 많아 봤자 트랜잭션마다 한 건에서 수만 건 정도밖에 안된다. 따라서 갱신 처리에 값비싼 메모리를 많이 사용하는 것보다는, 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각하는 것이다.

* 검색과 갱신에 관한 메모리 배분에 대한 부분 생략

<hr>

### 6. 추가적인 메모리 영역 '워킹 메모리'

- 언제 사용될까?

* DMBS는 앞에서 설명했던 2개의 버퍼 이외에도, 일반적으로 메모리 영역을 하나 더 가지고 있다. 이는 정렬 또는 해시 관련 처리에 사용되는 작업용 영역으로 **워킹 메모리(working memory)**라고 부른다. 정렬은 ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행된다. 반면 해시는 주로 테이블 등의 결합에서 해시 결합이 사용되는 때 실행된다.

### 메모리가 부족한 경우에는 디스크를 사용한다.

- 이 메모리 영역의 이름과 관리 방법은 DBMS에 따라 다르다. 이 작업용 메모리 영역은 SQL에서 정렬 또는 해시가 필요한 때 사용되고, 종료되면 해제되는 임시 영역으로, 일반적으로는 데이터 캐시와 로그 버퍼와는 다른 영역으로 관리되는 경우가 많다. 이 영역이 성능적으로 중요한 이유는, 만약 이 영역이 다루려는 데이터 양보다 작아 부족해지는 경우가 생기면 대부분의 DBMS가 저장소를 사용하기 때문이다. 이는 OS 동작에서 말하는 스왑(swap)과 같은 것이다.

* 부족하면 무슨 일이 일어날까?

- 저장소는 메모리에 비해서 굉장히 느리다. 따라서 그런 곳에 접근하게 되면 당연히 전체적인 속도가 느려진다.
- DBMS는 '메모리가 부족하더라도 무언가를 처리하려고 계속 노력하는 미들웨어'라고 생각할 수 있다. 사실 DBMS도 워킹 메모리가 부족할 때 곧바로 SQL 구문 처리를 중단하게 만들 수 있었다. 예를 들어 자바는 힙(heap) 크기가 부족하면 메모리 부족(out of memory)오류를 발생시켜 모든 처리를 중단시켜 버린다. 하지만 데이터베이스는 그러한 선택을 하지 않았고 메모리가 부족하다는 이유로 SQL 구문에 오류를 절대 발생시키지 않는다. 비록 느려지는 상황이 발생하더라도 상관없으니 어떻게든 끝까지 처리하려 노력한다. 이는 DBMS가 중요한 데이터를 보관하고 처리할 때, 운영체제 정도의 급으로 처리 계속성을 담보하려 하기 때문이다.
